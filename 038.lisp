#!/usr/local/bin/sbcl --script
(defun string-to-number-list (str)
 (let ((lst nil))
  (do ((i 0 (+ 1 i)))
   ((>= i (length str)) (reverse lst))
    (push (parse-integer str :start i :end (+ 1 i)) lst))))
(defun number-to-number-list (num)
 (string-to-number-list (format nil "~A" num)))
(defun pandigitalp (num)
 (let ((lst (number-to-number-list num)))
  (if (and
       (eql (length lst) 9)
       (find 1 lst)
       (find 2 lst)
       (find 3 lst)
       (find 4 lst)
       (find 5 lst)
       (find 6 lst)
       (find 7 lst)
       (find 8 lst)
       (find 9 lst))
   t
   nil)))
(defun list-to-number (lst)
 (let ((result 0))
 (do ((i (- (length lst) 1) (- i 1)) (j 0 (+ j 1)))
  ((eql j (length lst)) result)
  (setf result (+ result (* (expt 10 i) (nth j lst)))))))
(defun concatenatedproduct (num limit)
 (let ((lst nil))
  (do ((i 1 (+ i 1)))
   ((> i limit) (list-to-number lst))
   (setf lst (append lst (number-to-number-list (* num i)))))))
(defun list-of-pandigitals (num limit)
  (let ((val 0) (lst nil))
    (do ((i 2 (+ i 1)))
      ((> i limit) lst)
      (progn
        (setf val (concatenatedproduct num i))
        (if (pandigitalp val)
          (push val lst))))))
(defun full-list-of-pandigitals (numlimit explimit)
 (let ((lst nil))
  (do ((i 2 (+ i 1)))
   ((> i numlimit) lst)
   (setf lst (append lst (list-of-pandigitals i explimit))))))
(defun euler ()
 (apply #'max (full-list-of-pandigitals 10000 9)))
(defun output-to-screen (x)
  (write-line x))
(output-to-screen (format nil "~A" (euler)))
